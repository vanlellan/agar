/**
 * Agent
 *
 * Autonomous agent that plays agar.io
 *
 * Useage:
 *
 * agent = new Agent(state, controller);
 * agent.run();
 */
var _ = require('lodash');

var DEFAULT_STEP_TIMEOUT = 50;

/**
 * Agent
 *
 * @param {GameState} state
 * @param {Controller} controller
 * @return {Agent}
 */
function Agent(state, controller) {
  _.bindAll(this);
  this.state = state;
  this.controller = controller;
}
module.exports = Agent;

/**
 * run
 *
 * Start a run loop
 *
 * @param{number} stepTimeout Timeout in milliseconds to take between each step.
 * @return {undefined}
 */
Agent.prototype.run = function run(stepTimeout) {
  var self = this;

  // Only allow calling run once
  if (this.isRunning) {
    return;
  }
  this.isRunning = true;

  stepTimeout = stepTimeout || DEFAULT_STEP_TIMEOUT
  loop();

  function loop() {
    self.step();
    if (self.isRunning) {
      setTimeout(loop, stepTimeout);
    }
  }
};

/**
 * stop
 *
 * Stop the running agent
 *
 * @return {undefined}
 */
Agent.prototype.stop = function stop() {
  self.isRunning = false;
};

/**
 * step
 *
 * Take an in-game action
 *
 * @return {undefined}
 */
Agent.prototype.step = function step() {
  var user = this.state.getUserEntity();

  if (!user) {
    this.controller.sendInitMessage();
    this.controller.play();
    return;
  }

  var slopes = this.calcDirection(function(user, entity) {
    return entity.id !== user.id;
  });

//  console.log('xSlope = ' + slopes.ddx);
//  console.log('ySlope = ' + slopes.ddy);
  xNew = slopes.ddx/Math.sqrt(slopes.ddx*slopes.ddx + slopes.ddy*slopes.ddy)
  yNew = slopes.ddy/Math.sqrt(slopes.ddx*slopes.ddx + slopes.ddy*slopes.ddy)
  this.controller.move(user.x + 2*user.size*xNew, user.y + 2*user.size*yNew);

/**
  // Run away from entities that are larger and are within a certain distance.
  var nearestMonster = this.findNearestEntity(function(user, entity) {
    return entity.id !== user.id && 0.9*entity.size > user.size && !entity.isVirus;
  });

  if (nearestMonster) {
    var monsterDistance = distance(user, nearestMonster);
    // Keep at least 4 radii away from bigger entities
    if (monsterDistance < (4 * user.size)) {
      // Move away
      var xDelta = user.x - nearestMonster.x;
      var yDelta = user.y - nearestMonster.y
      this.controller.move(user.x + xDelta, user.y + yDelta);
      return;
    }
  }

  //Avoid eating Viruses
  var nearestVirus = this.findNearestEntity(function(user, entity) {
    return entity.id !== user.id && entity.size > user.size && entity.isVirus;
  });

  if (nearestVirus) {
    var virusDistance = distance(user, nearestVirus);
    // Keep at edge of virus
    if (virusDistance < 0) {
      // Move away
      var xDelta = user.x - nearestVirus.x;
      var yDelta = user.y - nearestVirus.y
      this.controller.move(user.x + xDelta, user.y + yDelta);
      return;
    }
  }


  //Eat nearest edible
  var nearestEdible = this.findNearestEntity(function(user, entity) {
    return entity.id !== user.id && entity.size < 0.9*user.size && !entity.isVirus;
  });

  if (nearestEdible) {
    this.controller.move(nearestEdible.x, nearestEdible.y);
  }
**/
};

/**
 * calcDirection
 *
 * Calculate optimal direction based on local slope of terrain function generated by all entities
 * Use simple cone (linear) PSRF for all entities
 *
 * @param {function(user, entity)} predicate Function that returns true/false.
 *   Filters entities to those that pass the predicate.
 * @return {undefined}
 */
Agent.prototype.calcDirection = function calcDirection(predicate) {
  var user = this.state.getUserEntity();
  var entities = this.state.getEntities();
  var xSlope = 0.0;
  var ySlope = 0.0;

  _.each(entities, function(entity) {
    if (!predicate(user, entity)) {
      return;
    }

    var rDistance = centDistance(user, entity);

    if (rDistance < 10*user.size) {
      var rD2 = rDistance*rDistance;
      var xDistance = user.x - entity.x;
      var yDistance = user.y - entity.y;

      var A = 0.0;
      if(entity.isVirus && entity.size<user.size ) {
        A = -entity.size*entity.size;
      }
      if(!entity.isVirus && entity.size>user.size) {
        A = -entity.size*entity.size;
      }
      if(!entity.isVirus && entity.size<0.9*user.size) {
        A = entity.size*entity.size;
      }
      var mu = entity.size;

//      var z = A*Math.exp(-rD2/mu);
//    var dzdx = -2*xDistance*z/(mu*rD2);
//    var dzdy = -2*yDistance*z/(mu*rD2);
      var dzdx = -A*xDistance/(rDistance*rDistance*rDistance+1);
      var dzdy = -A*yDistance/(rDistance*rDistance*rDistance+1);


      xSlope += dzdx;
      ySlope += dzdy;
    }

  });

  return {
    ddx: xSlope,
    ddy: ySlope
  };
}

/**
 * findNearestEntity
 *
 * Find the nearest entity that satisfies the predicate.
 *
 * @param {function(user, entity)} predicate Function that returns true/false.
 *   Filters entities to those that pass the predicate.
 * @return {undefined}
 */
Agent.prototype.findNearestEntity = function findNearestEntity(predicate) {
  var user = this.state.getUserEntity();
  var entities = this.state.getEntities();
  var nearestEntity = null;
  var nearestEntityDistance = Number.POSITIVE_INFINITY;

  _.each(entities, function(entity) {
    if (!predicate(user, entity)) {
      return;
    }

    var entityDistance = distance(user, entity);

    if (entityDistance < nearestEntityDistance) {
      nearestEntity = entity;
      nearestEntityDistance = entityDistance;
    }
  });

  return nearestEntity;
}

function centDistance(entity1, entity2) {
  var xDistance = entity1.x - entity2.x;
  var yDistance = entity1.y - entity2.y;
  var centerDistance = Math.sqrt((xDistance * xDistance) + (yDistance * yDistance));

  // The size is the radius, so remove it to get edge to edge distance
  return centerDistance;
}

/**
 * distance
 *
 * Calculate distance of entities from each other.
 *
 * @param entity1
 * @param entity2
 * @return {number}
 */
function distance(entity1, entity2) {
  var xDistance = entity1.x - entity2.x;
  var yDistance = entity1.y - entity2.y;
  var centerDistance = Math.sqrt((xDistance * xDistance) + (yDistance * yDistance));

  // The size is the radius, so remove it to get edge to edge distance
  return centerDistance - entity1.size - entity2.size;
}
